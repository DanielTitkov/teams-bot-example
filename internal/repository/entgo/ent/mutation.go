// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/DanielTitkov/teams-bot-example/internal/domain"
	"github.com/DanielTitkov/teams-bot-example/internal/repository/entgo/ent/dialog"
	"github.com/DanielTitkov/teams-bot-example/internal/repository/entgo/ent/message"
	"github.com/DanielTitkov/teams-bot-example/internal/repository/entgo/ent/project"
	"github.com/DanielTitkov/teams-bot-example/internal/repository/entgo/ent/user"

	"github.com/facebook/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDialog  = "Dialog"
	TypeMessage = "Message"
	TypeProject = "Project"
	TypeUser    = "User"
)

// DialogMutation represents an operation that mutate the Dialogs
// nodes in the graph.
type DialogMutation struct {
	config
	op             Op
	typ            string
	id             *int
	create_time    *time.Time
	update_time    *time.Time
	meta           *domain.DialogMeta
	clearedFields  map[string]struct{}
	message        map[int]struct{}
	removedmessage map[int]struct{}
	user           *int
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*Dialog, error)
}

var _ ent.Mutation = (*DialogMutation)(nil)

// dialogOption allows to manage the mutation configuration using functional options.
type dialogOption func(*DialogMutation)

// newDialogMutation creates new mutation for $n.Name.
func newDialogMutation(c config, op Op, opts ...dialogOption) *DialogMutation {
	m := &DialogMutation{
		config:        c,
		op:            op,
		typ:           TypeDialog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDialogID sets the id field of the mutation.
func withDialogID(id int) dialogOption {
	return func(m *DialogMutation) {
		var (
			err   error
			once  sync.Once
			value *Dialog
		)
		m.oldValue = func(ctx context.Context) (*Dialog, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Dialog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDialog sets the old Dialog of the mutation.
func withDialog(node *Dialog) dialogOption {
	return func(m *DialogMutation) {
		m.oldValue = func(context.Context) (*Dialog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DialogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DialogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DialogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *DialogMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *DialogMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Dialog.
// If the Dialog object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DialogMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *DialogMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *DialogMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *DialogMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Dialog.
// If the Dialog object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DialogMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *DialogMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetMeta sets the meta field.
func (m *DialogMutation) SetMeta(dm domain.DialogMeta) {
	m.meta = &dm
}

// Meta returns the meta value in the mutation.
func (m *DialogMutation) Meta() (r domain.DialogMeta, exists bool) {
	v := m.meta
	if v == nil {
		return
	}
	return *v, true
}

// OldMeta returns the old meta value of the Dialog.
// If the Dialog object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DialogMutation) OldMeta(ctx context.Context) (v domain.DialogMeta, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMeta is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMeta requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeta: %w", err)
	}
	return oldValue.Meta, nil
}

// ClearMeta clears the value of meta.
func (m *DialogMutation) ClearMeta() {
	m.meta = nil
	m.clearedFields[dialog.FieldMeta] = struct{}{}
}

// MetaCleared returns if the field meta was cleared in this mutation.
func (m *DialogMutation) MetaCleared() bool {
	_, ok := m.clearedFields[dialog.FieldMeta]
	return ok
}

// ResetMeta reset all changes of the "meta" field.
func (m *DialogMutation) ResetMeta() {
	m.meta = nil
	delete(m.clearedFields, dialog.FieldMeta)
}

// AddMessageIDs adds the message edge to Message by ids.
func (m *DialogMutation) AddMessageIDs(ids ...int) {
	if m.message == nil {
		m.message = make(map[int]struct{})
	}
	for i := range ids {
		m.message[ids[i]] = struct{}{}
	}
}

// RemoveMessageIDs removes the message edge to Message by ids.
func (m *DialogMutation) RemoveMessageIDs(ids ...int) {
	if m.removedmessage == nil {
		m.removedmessage = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmessage[ids[i]] = struct{}{}
	}
}

// RemovedMessage returns the removed ids of message.
func (m *DialogMutation) RemovedMessageIDs() (ids []int) {
	for id := range m.removedmessage {
		ids = append(ids, id)
	}
	return
}

// MessageIDs returns the message ids in the mutation.
func (m *DialogMutation) MessageIDs() (ids []int) {
	for id := range m.message {
		ids = append(ids, id)
	}
	return
}

// ResetMessage reset all changes of the "message" edge.
func (m *DialogMutation) ResetMessage() {
	m.message = nil
	m.removedmessage = nil
}

// SetUserID sets the user edge to User by id.
func (m *DialogMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the user edge to User.
func (m *DialogMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *DialogMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the user id in the mutation.
func (m *DialogMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the user ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *DialogMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *DialogMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Op returns the operation name.
func (m *DialogMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Dialog).
func (m *DialogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DialogMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, dialog.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, dialog.FieldUpdateTime)
	}
	if m.meta != nil {
		fields = append(fields, dialog.FieldMeta)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DialogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dialog.FieldCreateTime:
		return m.CreateTime()
	case dialog.FieldUpdateTime:
		return m.UpdateTime()
	case dialog.FieldMeta:
		return m.Meta()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DialogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dialog.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case dialog.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case dialog.FieldMeta:
		return m.OldMeta(ctx)
	}
	return nil, fmt.Errorf("unknown Dialog field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DialogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dialog.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case dialog.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case dialog.FieldMeta:
		v, ok := value.(domain.DialogMeta)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeta(v)
		return nil
	}
	return fmt.Errorf("unknown Dialog field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DialogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DialogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DialogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Dialog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DialogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dialog.FieldMeta) {
		fields = append(fields, dialog.FieldMeta)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DialogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DialogMutation) ClearField(name string) error {
	switch name {
	case dialog.FieldMeta:
		m.ClearMeta()
		return nil
	}
	return fmt.Errorf("unknown Dialog nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DialogMutation) ResetField(name string) error {
	switch name {
	case dialog.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case dialog.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case dialog.FieldMeta:
		m.ResetMeta()
		return nil
	}
	return fmt.Errorf("unknown Dialog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DialogMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.message != nil {
		edges = append(edges, dialog.EdgeMessage)
	}
	if m.user != nil {
		edges = append(edges, dialog.EdgeUser)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DialogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dialog.EdgeMessage:
		ids := make([]ent.Value, 0, len(m.message))
		for id := range m.message {
			ids = append(ids, id)
		}
		return ids
	case dialog.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DialogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmessage != nil {
		edges = append(edges, dialog.EdgeMessage)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DialogMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dialog.EdgeMessage:
		ids := make([]ent.Value, 0, len(m.removedmessage))
		for id := range m.removedmessage {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DialogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, dialog.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DialogMutation) EdgeCleared(name string) bool {
	switch name {
	case dialog.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DialogMutation) ClearEdge(name string) error {
	switch name {
	case dialog.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Dialog unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DialogMutation) ResetEdge(name string) error {
	switch name {
	case dialog.EdgeMessage:
		m.ResetMessage()
		return nil
	case dialog.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Dialog edge %s", name)
}

// MessageMutation represents an operation that mutate the Messages
// nodes in the graph.
type MessageMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	text          *string
	attachment    *string
	payload_type  *string
	payload_value *string
	system        *string
	direction     *string
	proactive     *bool
	error         *string
	clearedFields map[string]struct{}
	dialog        *int
	cleareddialog bool
	done          bool
	oldValue      func(context.Context) (*Message, error)
}

var _ ent.Mutation = (*MessageMutation)(nil)

// messageOption allows to manage the mutation configuration using functional options.
type messageOption func(*MessageMutation)

// newMessageMutation creates new mutation for $n.Name.
func newMessageMutation(c config, op Op, opts ...messageOption) *MessageMutation {
	m := &MessageMutation{
		config:        c,
		op:            op,
		typ:           TypeMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageID sets the id field of the mutation.
func withMessageID(id int) messageOption {
	return func(m *MessageMutation) {
		var (
			err   error
			once  sync.Once
			value *Message
		)
		m.oldValue = func(ctx context.Context) (*Message, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Message.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessage sets the old Message of the mutation.
func withMessage(node *Message) messageOption {
	return func(m *MessageMutation) {
		m.oldValue = func(context.Context) (*Message, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MessageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *MessageMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *MessageMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Message.
// If the Message object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MessageMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *MessageMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *MessageMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *MessageMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Message.
// If the Message object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MessageMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *MessageMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetText sets the text field.
func (m *MessageMutation) SetText(s string) {
	m.text = &s
}

// Text returns the text value in the mutation.
func (m *MessageMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old text value of the Message.
// If the Message object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MessageMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldText is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ClearText clears the value of text.
func (m *MessageMutation) ClearText() {
	m.text = nil
	m.clearedFields[message.FieldText] = struct{}{}
}

// TextCleared returns if the field text was cleared in this mutation.
func (m *MessageMutation) TextCleared() bool {
	_, ok := m.clearedFields[message.FieldText]
	return ok
}

// ResetText reset all changes of the "text" field.
func (m *MessageMutation) ResetText() {
	m.text = nil
	delete(m.clearedFields, message.FieldText)
}

// SetAttachment sets the attachment field.
func (m *MessageMutation) SetAttachment(s string) {
	m.attachment = &s
}

// Attachment returns the attachment value in the mutation.
func (m *MessageMutation) Attachment() (r string, exists bool) {
	v := m.attachment
	if v == nil {
		return
	}
	return *v, true
}

// OldAttachment returns the old attachment value of the Message.
// If the Message object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MessageMutation) OldAttachment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAttachment is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAttachment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttachment: %w", err)
	}
	return oldValue.Attachment, nil
}

// ClearAttachment clears the value of attachment.
func (m *MessageMutation) ClearAttachment() {
	m.attachment = nil
	m.clearedFields[message.FieldAttachment] = struct{}{}
}

// AttachmentCleared returns if the field attachment was cleared in this mutation.
func (m *MessageMutation) AttachmentCleared() bool {
	_, ok := m.clearedFields[message.FieldAttachment]
	return ok
}

// ResetAttachment reset all changes of the "attachment" field.
func (m *MessageMutation) ResetAttachment() {
	m.attachment = nil
	delete(m.clearedFields, message.FieldAttachment)
}

// SetPayloadType sets the payload_type field.
func (m *MessageMutation) SetPayloadType(s string) {
	m.payload_type = &s
}

// PayloadType returns the payload_type value in the mutation.
func (m *MessageMutation) PayloadType() (r string, exists bool) {
	v := m.payload_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPayloadType returns the old payload_type value of the Message.
// If the Message object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MessageMutation) OldPayloadType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPayloadType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPayloadType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayloadType: %w", err)
	}
	return oldValue.PayloadType, nil
}

// ClearPayloadType clears the value of payload_type.
func (m *MessageMutation) ClearPayloadType() {
	m.payload_type = nil
	m.clearedFields[message.FieldPayloadType] = struct{}{}
}

// PayloadTypeCleared returns if the field payload_type was cleared in this mutation.
func (m *MessageMutation) PayloadTypeCleared() bool {
	_, ok := m.clearedFields[message.FieldPayloadType]
	return ok
}

// ResetPayloadType reset all changes of the "payload_type" field.
func (m *MessageMutation) ResetPayloadType() {
	m.payload_type = nil
	delete(m.clearedFields, message.FieldPayloadType)
}

// SetPayloadValue sets the payload_value field.
func (m *MessageMutation) SetPayloadValue(s string) {
	m.payload_value = &s
}

// PayloadValue returns the payload_value value in the mutation.
func (m *MessageMutation) PayloadValue() (r string, exists bool) {
	v := m.payload_value
	if v == nil {
		return
	}
	return *v, true
}

// OldPayloadValue returns the old payload_value value of the Message.
// If the Message object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MessageMutation) OldPayloadValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPayloadValue is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPayloadValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayloadValue: %w", err)
	}
	return oldValue.PayloadValue, nil
}

// ClearPayloadValue clears the value of payload_value.
func (m *MessageMutation) ClearPayloadValue() {
	m.payload_value = nil
	m.clearedFields[message.FieldPayloadValue] = struct{}{}
}

// PayloadValueCleared returns if the field payload_value was cleared in this mutation.
func (m *MessageMutation) PayloadValueCleared() bool {
	_, ok := m.clearedFields[message.FieldPayloadValue]
	return ok
}

// ResetPayloadValue reset all changes of the "payload_value" field.
func (m *MessageMutation) ResetPayloadValue() {
	m.payload_value = nil
	delete(m.clearedFields, message.FieldPayloadValue)
}

// SetSystem sets the system field.
func (m *MessageMutation) SetSystem(s string) {
	m.system = &s
}

// System returns the system value in the mutation.
func (m *MessageMutation) System() (r string, exists bool) {
	v := m.system
	if v == nil {
		return
	}
	return *v, true
}

// OldSystem returns the old system value of the Message.
// If the Message object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MessageMutation) OldSystem(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSystem is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSystem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystem: %w", err)
	}
	return oldValue.System, nil
}

// ResetSystem reset all changes of the "system" field.
func (m *MessageMutation) ResetSystem() {
	m.system = nil
}

// SetDirection sets the direction field.
func (m *MessageMutation) SetDirection(s string) {
	m.direction = &s
}

// Direction returns the direction value in the mutation.
func (m *MessageMutation) Direction() (r string, exists bool) {
	v := m.direction
	if v == nil {
		return
	}
	return *v, true
}

// OldDirection returns the old direction value of the Message.
// If the Message object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MessageMutation) OldDirection(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDirection is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDirection requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirection: %w", err)
	}
	return oldValue.Direction, nil
}

// ResetDirection reset all changes of the "direction" field.
func (m *MessageMutation) ResetDirection() {
	m.direction = nil
}

// SetProactive sets the proactive field.
func (m *MessageMutation) SetProactive(b bool) {
	m.proactive = &b
}

// Proactive returns the proactive value in the mutation.
func (m *MessageMutation) Proactive() (r bool, exists bool) {
	v := m.proactive
	if v == nil {
		return
	}
	return *v, true
}

// OldProactive returns the old proactive value of the Message.
// If the Message object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MessageMutation) OldProactive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProactive is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProactive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProactive: %w", err)
	}
	return oldValue.Proactive, nil
}

// ResetProactive reset all changes of the "proactive" field.
func (m *MessageMutation) ResetProactive() {
	m.proactive = nil
}

// SetError sets the error field.
func (m *MessageMutation) SetError(s string) {
	m.error = &s
}

// Error returns the error value in the mutation.
func (m *MessageMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old error value of the Message.
// If the Message object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MessageMutation) OldError(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldError is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of error.
func (m *MessageMutation) ClearError() {
	m.error = nil
	m.clearedFields[message.FieldError] = struct{}{}
}

// ErrorCleared returns if the field error was cleared in this mutation.
func (m *MessageMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[message.FieldError]
	return ok
}

// ResetError reset all changes of the "error" field.
func (m *MessageMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, message.FieldError)
}

// SetDialogID sets the dialog edge to Dialog by id.
func (m *MessageMutation) SetDialogID(id int) {
	m.dialog = &id
}

// ClearDialog clears the dialog edge to Dialog.
func (m *MessageMutation) ClearDialog() {
	m.cleareddialog = true
}

// DialogCleared returns if the edge dialog was cleared.
func (m *MessageMutation) DialogCleared() bool {
	return m.cleareddialog
}

// DialogID returns the dialog id in the mutation.
func (m *MessageMutation) DialogID() (id int, exists bool) {
	if m.dialog != nil {
		return *m.dialog, true
	}
	return
}

// DialogIDs returns the dialog ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DialogID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) DialogIDs() (ids []int) {
	if id := m.dialog; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDialog reset all changes of the "dialog" edge.
func (m *MessageMutation) ResetDialog() {
	m.dialog = nil
	m.cleareddialog = false
}

// Op returns the operation name.
func (m *MessageMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Message).
func (m *MessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MessageMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, message.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, message.FieldUpdateTime)
	}
	if m.text != nil {
		fields = append(fields, message.FieldText)
	}
	if m.attachment != nil {
		fields = append(fields, message.FieldAttachment)
	}
	if m.payload_type != nil {
		fields = append(fields, message.FieldPayloadType)
	}
	if m.payload_value != nil {
		fields = append(fields, message.FieldPayloadValue)
	}
	if m.system != nil {
		fields = append(fields, message.FieldSystem)
	}
	if m.direction != nil {
		fields = append(fields, message.FieldDirection)
	}
	if m.proactive != nil {
		fields = append(fields, message.FieldProactive)
	}
	if m.error != nil {
		fields = append(fields, message.FieldError)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case message.FieldCreateTime:
		return m.CreateTime()
	case message.FieldUpdateTime:
		return m.UpdateTime()
	case message.FieldText:
		return m.Text()
	case message.FieldAttachment:
		return m.Attachment()
	case message.FieldPayloadType:
		return m.PayloadType()
	case message.FieldPayloadValue:
		return m.PayloadValue()
	case message.FieldSystem:
		return m.System()
	case message.FieldDirection:
		return m.Direction()
	case message.FieldProactive:
		return m.Proactive()
	case message.FieldError:
		return m.Error()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case message.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case message.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case message.FieldText:
		return m.OldText(ctx)
	case message.FieldAttachment:
		return m.OldAttachment(ctx)
	case message.FieldPayloadType:
		return m.OldPayloadType(ctx)
	case message.FieldPayloadValue:
		return m.OldPayloadValue(ctx)
	case message.FieldSystem:
		return m.OldSystem(ctx)
	case message.FieldDirection:
		return m.OldDirection(ctx)
	case message.FieldProactive:
		return m.OldProactive(ctx)
	case message.FieldError:
		return m.OldError(ctx)
	}
	return nil, fmt.Errorf("unknown Message field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case message.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case message.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case message.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case message.FieldAttachment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttachment(v)
		return nil
	case message.FieldPayloadType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayloadType(v)
		return nil
	case message.FieldPayloadValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayloadValue(v)
		return nil
	case message.FieldSystem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystem(v)
		return nil
	case message.FieldDirection:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirection(v)
		return nil
	case message.FieldProactive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProactive(v)
		return nil
	case message.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MessageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MessageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Message numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(message.FieldText) {
		fields = append(fields, message.FieldText)
	}
	if m.FieldCleared(message.FieldAttachment) {
		fields = append(fields, message.FieldAttachment)
	}
	if m.FieldCleared(message.FieldPayloadType) {
		fields = append(fields, message.FieldPayloadType)
	}
	if m.FieldCleared(message.FieldPayloadValue) {
		fields = append(fields, message.FieldPayloadValue)
	}
	if m.FieldCleared(message.FieldError) {
		fields = append(fields, message.FieldError)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageMutation) ClearField(name string) error {
	switch name {
	case message.FieldText:
		m.ClearText()
		return nil
	case message.FieldAttachment:
		m.ClearAttachment()
		return nil
	case message.FieldPayloadType:
		m.ClearPayloadType()
		return nil
	case message.FieldPayloadValue:
		m.ClearPayloadValue()
		return nil
	case message.FieldError:
		m.ClearError()
		return nil
	}
	return fmt.Errorf("unknown Message nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MessageMutation) ResetField(name string) error {
	switch name {
	case message.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case message.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case message.FieldText:
		m.ResetText()
		return nil
	case message.FieldAttachment:
		m.ResetAttachment()
		return nil
	case message.FieldPayloadType:
		m.ResetPayloadType()
		return nil
	case message.FieldPayloadValue:
		m.ResetPayloadValue()
		return nil
	case message.FieldSystem:
		m.ResetSystem()
		return nil
	case message.FieldDirection:
		m.ResetDirection()
		return nil
	case message.FieldProactive:
		m.ResetProactive()
		return nil
	case message.FieldError:
		m.ResetError()
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.dialog != nil {
		edges = append(edges, message.EdgeDialog)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeDialog:
		if id := m.dialog; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MessageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddialog {
		edges = append(edges, message.EdgeDialog)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MessageMutation) EdgeCleared(name string) bool {
	switch name {
	case message.EdgeDialog:
		return m.cleareddialog
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MessageMutation) ClearEdge(name string) error {
	switch name {
	case message.EdgeDialog:
		m.ClearDialog()
		return nil
	}
	return fmt.Errorf("unknown Message unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MessageMutation) ResetEdge(name string) error {
	switch name {
	case message.EdgeDialog:
		m.ResetDialog()
		return nil
	}
	return fmt.Errorf("unknown Message edge %s", name)
}

// ProjectMutation represents an operation that mutate the Projects
// nodes in the graph.
type ProjectMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	title         *string
	due_date      *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Project, error)
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows to manage the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for $n.Name.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the id field of the mutation.
func withProjectID(id int) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *ProjectMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *ProjectMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Project.
// If the Project object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProjectMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *ProjectMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *ProjectMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *ProjectMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Project.
// If the Project object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProjectMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *ProjectMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetTitle sets the title field.
func (m *ProjectMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the title value in the mutation.
func (m *ProjectMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old title value of the Project.
// If the Project object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProjectMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle reset all changes of the "title" field.
func (m *ProjectMutation) ResetTitle() {
	m.title = nil
}

// SetDueDate sets the due_date field.
func (m *ProjectMutation) SetDueDate(t time.Time) {
	m.due_date = &t
}

// DueDate returns the due_date value in the mutation.
func (m *ProjectMutation) DueDate() (r time.Time, exists bool) {
	v := m.due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old due_date value of the Project.
// If the Project object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProjectMutation) OldDueDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDueDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ResetDueDate reset all changes of the "due_date" field.
func (m *ProjectMutation) ResetDueDate() {
	m.due_date = nil
}

// SetUserID sets the user edge to User by id.
func (m *ProjectMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the user edge to User.
func (m *ProjectMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *ProjectMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the user id in the mutation.
func (m *ProjectMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the user ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *ProjectMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, project.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, project.FieldUpdateTime)
	}
	if m.title != nil {
		fields = append(fields, project.FieldTitle)
	}
	if m.due_date != nil {
		fields = append(fields, project.FieldDueDate)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldCreateTime:
		return m.CreateTime()
	case project.FieldUpdateTime:
		return m.UpdateTime()
	case project.FieldTitle:
		return m.Title()
	case project.FieldDueDate:
		return m.DueDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case project.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case project.FieldTitle:
		return m.OldTitle(ctx)
	case project.FieldDueDate:
		return m.OldDueDate(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case project.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case project.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case project.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ProjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ProjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case project.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case project.FieldTitle:
		m.ResetTitle()
		return nil
	case project.FieldDueDate:
		m.ResetDueDate()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, project.EdgeUser)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, project.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	case project.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op              Op
	typ             string
	id              *int
	create_time     *time.Time
	update_time     *time.Time
	username        *string
	display_name    *string
	email           *string
	password_hash   *string
	service         *bool
	teams_id        *string
	telegram_id     *string
	slack_id        *string
	clearedFields   map[string]struct{}
	dialog          *int
	cleareddialog   bool
	projects        map[int]struct{}
	removedprojects map[int]struct{}
	done            bool
	oldValue        func(context.Context) (*User, error)
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *UserMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *UserMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *UserMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *UserMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *UserMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *UserMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetUsername sets the username field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the username value in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old username value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsername is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername reset all changes of the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetDisplayName sets the display_name field.
func (m *UserMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the display_name value in the mutation.
func (m *UserMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old display_name value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisplayName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of display_name.
func (m *UserMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[user.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the field display_name was cleared in this mutation.
func (m *UserMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[user.FieldDisplayName]
	return ok
}

// ResetDisplayName reset all changes of the "display_name" field.
func (m *UserMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, user.FieldDisplayName)
}

// SetEmail sets the email field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of email.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the field email was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail reset all changes of the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetPasswordHash sets the password_hash field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the password_hash value in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old password_hash value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPasswordHash is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash reset all changes of the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetService sets the service field.
func (m *UserMutation) SetService(b bool) {
	m.service = &b
}

// Service returns the service value in the mutation.
func (m *UserMutation) Service() (r bool, exists bool) {
	v := m.service
	if v == nil {
		return
	}
	return *v, true
}

// OldService returns the old service value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldService(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldService is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldService requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldService: %w", err)
	}
	return oldValue.Service, nil
}

// ResetService reset all changes of the "service" field.
func (m *UserMutation) ResetService() {
	m.service = nil
}

// SetTeamsID sets the teams_id field.
func (m *UserMutation) SetTeamsID(s string) {
	m.teams_id = &s
}

// TeamsID returns the teams_id value in the mutation.
func (m *UserMutation) TeamsID() (r string, exists bool) {
	v := m.teams_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamsID returns the old teams_id value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldTeamsID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTeamsID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTeamsID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamsID: %w", err)
	}
	return oldValue.TeamsID, nil
}

// ClearTeamsID clears the value of teams_id.
func (m *UserMutation) ClearTeamsID() {
	m.teams_id = nil
	m.clearedFields[user.FieldTeamsID] = struct{}{}
}

// TeamsIDCleared returns if the field teams_id was cleared in this mutation.
func (m *UserMutation) TeamsIDCleared() bool {
	_, ok := m.clearedFields[user.FieldTeamsID]
	return ok
}

// ResetTeamsID reset all changes of the "teams_id" field.
func (m *UserMutation) ResetTeamsID() {
	m.teams_id = nil
	delete(m.clearedFields, user.FieldTeamsID)
}

// SetTelegramID sets the telegram_id field.
func (m *UserMutation) SetTelegramID(s string) {
	m.telegram_id = &s
}

// TelegramID returns the telegram_id value in the mutation.
func (m *UserMutation) TelegramID() (r string, exists bool) {
	v := m.telegram_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTelegramID returns the old telegram_id value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldTelegramID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTelegramID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTelegramID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelegramID: %w", err)
	}
	return oldValue.TelegramID, nil
}

// ClearTelegramID clears the value of telegram_id.
func (m *UserMutation) ClearTelegramID() {
	m.telegram_id = nil
	m.clearedFields[user.FieldTelegramID] = struct{}{}
}

// TelegramIDCleared returns if the field telegram_id was cleared in this mutation.
func (m *UserMutation) TelegramIDCleared() bool {
	_, ok := m.clearedFields[user.FieldTelegramID]
	return ok
}

// ResetTelegramID reset all changes of the "telegram_id" field.
func (m *UserMutation) ResetTelegramID() {
	m.telegram_id = nil
	delete(m.clearedFields, user.FieldTelegramID)
}

// SetSlackID sets the slack_id field.
func (m *UserMutation) SetSlackID(s string) {
	m.slack_id = &s
}

// SlackID returns the slack_id value in the mutation.
func (m *UserMutation) SlackID() (r string, exists bool) {
	v := m.slack_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSlackID returns the old slack_id value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldSlackID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSlackID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSlackID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlackID: %w", err)
	}
	return oldValue.SlackID, nil
}

// ClearSlackID clears the value of slack_id.
func (m *UserMutation) ClearSlackID() {
	m.slack_id = nil
	m.clearedFields[user.FieldSlackID] = struct{}{}
}

// SlackIDCleared returns if the field slack_id was cleared in this mutation.
func (m *UserMutation) SlackIDCleared() bool {
	_, ok := m.clearedFields[user.FieldSlackID]
	return ok
}

// ResetSlackID reset all changes of the "slack_id" field.
func (m *UserMutation) ResetSlackID() {
	m.slack_id = nil
	delete(m.clearedFields, user.FieldSlackID)
}

// SetDialogID sets the dialog edge to Dialog by id.
func (m *UserMutation) SetDialogID(id int) {
	m.dialog = &id
}

// ClearDialog clears the dialog edge to Dialog.
func (m *UserMutation) ClearDialog() {
	m.cleareddialog = true
}

// DialogCleared returns if the edge dialog was cleared.
func (m *UserMutation) DialogCleared() bool {
	return m.cleareddialog
}

// DialogID returns the dialog id in the mutation.
func (m *UserMutation) DialogID() (id int, exists bool) {
	if m.dialog != nil {
		return *m.dialog, true
	}
	return
}

// DialogIDs returns the dialog ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DialogID instead. It exists only for internal usage by the builders.
func (m *UserMutation) DialogIDs() (ids []int) {
	if id := m.dialog; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDialog reset all changes of the "dialog" edge.
func (m *UserMutation) ResetDialog() {
	m.dialog = nil
	m.cleareddialog = false
}

// AddProjectIDs adds the projects edge to Project by ids.
func (m *UserMutation) AddProjectIDs(ids ...int) {
	if m.projects == nil {
		m.projects = make(map[int]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// RemoveProjectIDs removes the projects edge to Project by ids.
func (m *UserMutation) RemoveProjectIDs(ids ...int) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[int]struct{})
	}
	for i := range ids {
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed ids of projects.
func (m *UserMutation) RemovedProjectsIDs() (ids []int) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the projects ids in the mutation.
func (m *UserMutation) ProjectsIDs() (ids []int) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects reset all changes of the "projects" edge.
func (m *UserMutation) ResetProjects() {
	m.projects = nil
	m.removedprojects = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, user.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, user.FieldUpdateTime)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.display_name != nil {
		fields = append(fields, user.FieldDisplayName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.service != nil {
		fields = append(fields, user.FieldService)
	}
	if m.teams_id != nil {
		fields = append(fields, user.FieldTeamsID)
	}
	if m.telegram_id != nil {
		fields = append(fields, user.FieldTelegramID)
	}
	if m.slack_id != nil {
		fields = append(fields, user.FieldSlackID)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreateTime:
		return m.CreateTime()
	case user.FieldUpdateTime:
		return m.UpdateTime()
	case user.FieldUsername:
		return m.Username()
	case user.FieldDisplayName:
		return m.DisplayName()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldService:
		return m.Service()
	case user.FieldTeamsID:
		return m.TeamsID()
	case user.FieldTelegramID:
		return m.TelegramID()
	case user.FieldSlackID:
		return m.SlackID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case user.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldService:
		return m.OldService(ctx)
	case user.FieldTeamsID:
		return m.OldTeamsID(ctx)
	case user.FieldTelegramID:
		return m.OldTelegramID(ctx)
	case user.FieldSlackID:
		return m.OldSlackID(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case user.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldService:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetService(v)
		return nil
	case user.FieldTeamsID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamsID(v)
		return nil
	case user.FieldTelegramID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelegramID(v)
		return nil
	case user.FieldSlackID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlackID(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDisplayName) {
		fields = append(fields, user.FieldDisplayName)
	}
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldTeamsID) {
		fields = append(fields, user.FieldTeamsID)
	}
	if m.FieldCleared(user.FieldTelegramID) {
		fields = append(fields, user.FieldTelegramID)
	}
	if m.FieldCleared(user.FieldSlackID) {
		fields = append(fields, user.FieldSlackID)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldTeamsID:
		m.ClearTeamsID()
		return nil
	case user.FieldTelegramID:
		m.ClearTelegramID()
		return nil
	case user.FieldSlackID:
		m.ClearSlackID()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case user.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldService:
		m.ResetService()
		return nil
	case user.FieldTeamsID:
		m.ResetTeamsID()
		return nil
	case user.FieldTelegramID:
		m.ResetTelegramID()
		return nil
	case user.FieldSlackID:
		m.ResetSlackID()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.dialog != nil {
		edges = append(edges, user.EdgeDialog)
	}
	if m.projects != nil {
		edges = append(edges, user.EdgeProjects)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeDialog:
		if id := m.dialog; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedprojects != nil {
		edges = append(edges, user.EdgeProjects)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddialog {
		edges = append(edges, user.EdgeDialog)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeDialog:
		return m.cleareddialog
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeDialog:
		m.ClearDialog()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeDialog:
		m.ResetDialog()
		return nil
	case user.EdgeProjects:
		m.ResetProjects()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
